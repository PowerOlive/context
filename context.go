// Package context provides a mechanism for transparently tracking contextual
// state associated to the current goroutine and even across goroutines.
package context

import (
	"sync"
)

var (
	contexts = make(map[uint64]*context)
	global   = make(Map)

	allmx sync.RWMutex
)

// Contextual is an interface for anything that maintains its own context.
type Contextual interface {
	// Fill fills the given Map with all of this Contextual's context
	Fill(m Map)
}

// Map is a map of key->value pairs.
type Map map[string]interface{}

// Fill implements the method from the Contextual interface.
func (_m Map) Fill(m Map) {
	for key, value := range _m {
		m[key] = value
	}
}

// Context is a context containing key->value pairs
type Context interface {
	// Enter enters a new level on this Context stack.
	Enter() Context

	// Go starts the given function on a new goroutine.
	Go(fn func())

	// Exit exits the current level on this Context stack.
	Exit()

	// Put puts a key->value pair into the current level of the context stack.
	Put(key string, value interface{}) Context

	// PutIfAbsent puts the given key->value pair into the current level of the
	// context stack if and only if that key is defined nowhere within the context
	// stack (including parent contexts).
	PutIfAbsent(key string, value interface{}) Context

	// PutDynamic puts a key->value pair into the current level of the context stack
	// where the value is generated by a function that gets evaluated at every Read.
	PutDynamic(key string, valueFN func() interface{}) Context

	// Fill fills the given map with data from this Context
	Fill(m Map)

	// AsMap returns a map containing all values from the supplied obj if it is a
	// Contextual, plus any addition values from along the stack, plus globals if
	// so specified.
	AsMap(obj interface{}, includeGlobals bool) Map
}

type context struct {
	id           uint64
	parent       *context
	branchedFrom *context
	data         Map
	mx           sync.RWMutex
}

type dynval struct {
	fn func() interface{}
}

// Enter enters a new level on the current Context stack, creating a new Context
// if necessary.
func Enter() Context {
	id := curGoroutineID()
	allmx.Lock()
	c := contexts[id]
	if c == nil {
		c = makeContext(id, nil, nil)
		contexts[id] = c
		allmx.Unlock()
		return c
	}
	allmx.Unlock()
	return c.Enter()
}

func (c *context) Enter() Context {
	c.mx.RLock()
	id := c.id
	c.mx.RUnlock()
	next := makeContext(id, c, nil)
	allmx.Lock()
	contexts[id] = next
	allmx.Unlock()
	return next
}

func (c *context) Go(fn func()) {
	go func() {
		id := curGoroutineID()
		next := makeContext(id, nil, c)
		allmx.Lock()
		contexts[id] = next
		allmx.Unlock()
		fn()
		// Clean up the context
		allmx.Lock()
		delete(contexts, id)
		allmx.Unlock()
	}()
}

// Go starts the given function on a new goroutine but sharing the context of
// the current goroutine (if it has one).
func Go(fn func()) {
	c := currentContext()
	if c != nil {
		c.Go(fn)
	} else {
		go fn()
	}
}

func makeContext(id uint64, parent *context, branchedFrom *context) *context {
	return &context{
		id:           id,
		parent:       parent,
		branchedFrom: branchedFrom,
		data:         make(Map),
	}
}

func (c *context) Exit() {
	c.mx.RLock()
	id := c.id
	parent := c.parent
	c.mx.RUnlock()
	if parent == nil {
		allmx.Lock()
		delete(contexts, id)
		allmx.Unlock()
		return
	}
	allmx.Lock()
	contexts[id] = parent
	allmx.Unlock()
}

func (c *context) Put(key string, value interface{}) Context {
	c.mx.Lock()
	c.data[key] = value
	c.mx.Unlock()
	return c
}

func (c *context) PutIfAbsent(key string, value interface{}) Context {
	for ctx := c; ctx != nil; {
		ctx.mx.RLock()
		_, exists := ctx.data[key]
		next := ctx.parent
		if next == nil {
			next = ctx.branchedFrom
		}
		ctx.mx.RUnlock()
		if exists {
			return c
		}
		ctx = next
	}

	// Value not set, set it
	return c.Put(key, value)
}

// PutGlobal puts the given key->value pair into the globalc context.
func PutGlobal(key string, value interface{}) {
	allmx.Lock()
	global[key] = value
	allmx.Unlock()
}

func (c *context) PutDynamic(key string, valueFN func() interface{}) Context {
	value := &dynval{valueFN}
	c.mx.Lock()
	c.data[key] = value
	c.mx.Unlock()
	return c
}

// PutGlobalDynamic puts a key->value pair into the global context wwhere the value is
// generated by a function that gets evaluated at every Read.
func PutGlobalDynamic(key string, valueFN func() interface{}) {
	value := &dynval{valueFN}
	allmx.Lock()
	global[key] = value
	allmx.Unlock()
}

func (c *context) Fill(m Map) {
	for ctx := c; ctx != nil; {
		ctx.mx.RLock()
		fill(m, ctx.data)
		next := ctx.parent
		if next == nil {
			next = ctx.branchedFrom
		}
		ctx.mx.RUnlock()
		ctx = next
	}
}

// AsMap returns a map containing all values from the supplied obj if it is a
// Contextual, plus any addition values from along the stack, plus globals if so
// specified.
func AsMap(obj interface{}, includeGlobals bool) Map {
	return currentContext().AsMap(obj, includeGlobals)
}

func (c *context) AsMap(obj interface{}, includeGlobals bool) Map {
	result := make(Map, 0)
	cl, ok := obj.(Contextual)
	if ok {
		cl.Fill(result)
	}
	if c != nil {
		c.Fill(result)
	}
	if includeGlobals {
		allmx.RLock()
		fill(result, global)
		allmx.RUnlock()
	}
	return result
}

func fill(m Map, from Map) {
	if m != nil {
		for key, value := range from {
			_, alreadyRead := m[key]
			if !alreadyRead {
				switch v := value.(type) {
				case *dynval:
					m[key] = v.fn()
				default:
					m[key] = v
				}
			}
		}
	}
}

func currentContext() *context {
	id := curGoroutineID()
	allmx.RLock()
	c := contexts[id]
	allmx.RUnlock()
	return c
}
