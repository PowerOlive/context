package context

import (
	"sync"
)

var (
	contexts = make(map[uint64]*Context)

	allmx sync.RWMutex
)

// Map is a map of key->value pairs
type Map map[string]interface{}

// Context is a context containing key->value pairs
type Context struct {
	id      uint64
	parent  *Context
	initial Map
	data    Map
	mx      sync.RWMutex
}

type dynval struct {
	fn func() interface{}
}

// Enter enters a new level on the current Context stack, creating a new Context
// if necessary.
func Enter() *Context {
	id := curGoroutineID()
	allmx.Lock()
	c := contexts[id]
	if c == nil {
		c = makeContext(id, nil, nil)
		contexts[id] = c
		allmx.Unlock()
		return c
	}
	allmx.Unlock()
	return c.Enter()
}

// Enter enters a new level on this Context stack.
func (c *Context) Enter() *Context {
	c.mx.RLock()
	id := c.id
	c.mx.RUnlock()
	next := makeContext(id, c, nil)
	allmx.Lock()
	contexts[id] = next
	allmx.Unlock()
	return next
}

// Go starts the given function on a new goroutine using a copy of the values
// from the original context.
func (c *Context) Go(fn func()) {
	initial := c.AsMap()
	go func() {
		id := curGoroutineID()
		c := makeContext(id, nil, initial)
		allmx.Lock()
		contexts[id] = c
		allmx.Unlock()
		fn()
		// Clean up the context
		allmx.Lock()
		delete(contexts, id)
		allmx.Unlock()
	}()
}

// Go starts the given function on a new goroutine but sharing the context of
// the current goroutine (if it has one).
func Go(fn func()) {
	c := currentContext()
	if c != nil {
		c.Go(fn)
	} else {
		go fn()
	}
}

func makeContext(id uint64, parent *Context, initial Map) *Context {
	return &Context{
		id:      id,
		parent:  parent,
		initial: initial,
		data:    make(Map),
	}
}

// Exit exits the current level on this Context stack.
func (c *Context) Exit() *Context {
	c.mx.RLock()
	id := c.id
	parent := c.parent
	c.mx.RUnlock()
	if parent == nil {
		allmx.Lock()
		delete(contexts, id)
		allmx.Unlock()
		return nil
	}
	allmx.Lock()
	contexts[id] = parent
	allmx.Unlock()
	return parent
}

// Put puts a key->value pair into the current level of the context stack.
func (c *Context) Put(key string, value interface{}) *Context {
	c.mx.Lock()
	c.data[key] = value
	c.mx.Unlock()
	return c
}

// PutDynamic puts a key->value pair into the current level of the context stack
// where the value is generated by a function that gets evaluated at every Read.
func (c *Context) PutDynamic(key string, valueFN func() interface{}) *Context {
	value := &dynval{valueFN}
	c.mx.Lock()
	c.data[key] = value
	c.mx.Unlock()
	return c
}

// Read reads all values on the context stack, starting at the current level and
// ascending. Duplicated keys at higher levels are not read.
func (c *Context) Read(cb func(key string, value interface{})) {
	knownKeys := make(Map, 0)
	for ctx := c; ctx != nil; {
		ctx.mx.RLock()
		read(knownKeys, cb, ctx.data)
		read(knownKeys, cb, ctx.initial)
		parent := ctx.parent
		ctx.mx.RUnlock()
		ctx = parent
	}
}

func read(knownKeys Map, cb func(key string, value interface{}), m Map) {
	if m != nil {
		for key, value := range m {
			_, alreadyRead := knownKeys[key]
			if !alreadyRead {
				switch v := value.(type) {
				case *dynval:
					cb(key, v.fn())
				default:
					cb(key, v)
				}
				knownKeys[key] = nil
			}
		}
	}
}

// Read calls Read() on the Context stack associated with the current goroutine.
func Read(cb func(key string, value interface{})) {
	c := currentContext()
	if c != nil {
		c.Read(cb)
	}
}

// AsMap returns a map containing all values along the stack.
func (c *Context) AsMap() Map {
	result := make(Map)
	c.Read(func(key string, value interface{}) {
		result[key] = value
	})
	return result
}

// AsMap returns a map containing all values along the stack.
func AsMap() Map {
	c := currentContext()
	if c == nil {
		return make(Map)
	}
	return c.AsMap()
}

func currentContext() *Context {
	id := curGoroutineID()
	allmx.RLock()
	c := contexts[id]
	allmx.RUnlock()
	return c
}
